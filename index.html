<!DOCTYPE html>
<html>
<head>
    <script type="text/javascript"
    src="https://www.maths.nottingham.ac.uk/plp/pmadw/LaTeXMathML.js">
    </script>

    <p> </p>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

    body, html {
    margin: 0;
    padding: 0;
    font-family: Arial, Helvetica, sans-serif;
    }

    figure {
    border: 1px #cccccc solid;
    padding: 4px;
    margin: auto;
    text-align: center;
    }

    .row {
    display: flex;
    }

    .column {
    flex: 50%;
    padding: 5px;
    }

    figcaption {
    background-color: black;
    color: white;
    font-style: italic;
    padding: 2px;
    text-align: center;
    }

    .top-container {
    padding: 100px;
    background-image:url('imgs/mafia.jpeg');
    /* background-repeat: no-repeat; */
    background-position: center;
    background-size: 25%;
    position: relative;
    object-fit: cover;
    width: auto;
    height: 150px;
    }

    .title {
    padding: 200px;
    text-align: center;
    color: black;
    }

    .topnav {
    overflow: hidden;
    background-color: #8B0000;
    }

    .topnav a {
    float: left;
    color: #f2f2f2;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
    font-size: 17px;
    }

    .topnav a:hover {
    background-color: #ddd;
    color: black;
    }

    .content {
    padding: 16px;
    }

    .sticky {
    position: fixed;
    top: 0;
    width: 100%;
    }

    .sticky + .content {
    padding-top: 102px;
    }

    #game-log {
      height: 300px;
      width: 500px;
      border: 1px solid black;
      overflow: auto;
    }
    </style>
    </head>
<body>

<div class="top-container">
</div>

<div class="topnav" id="myHeader">
        <a href="#abstract">Abstract</a>
        <a href="#introduction">Introduction</a>
        <a href="#code">Code</a>
        <a href="#kripke_model">Kripke Model</a>
        <a href="#results_discussion">Results and Discussion</a>
        <a href="#conclusion">Conclusion</a>
        <a href="#contributions">Contributions</a>
        <a href="#references">References</a>
        <a href="https://github.com/BlueVelvetSackOfGoldPotatoes/Lamas" target=”_blank”>GitHub</a>
</div>
<div class="title" >
    <h3>Mafia Game</h3>
    <p>Group 4: s4721810, s3450295, and s3486427.</p>
    </div>
<div class="content">
  <a id="abstract"></a>
  <h2>Abstract</h2>
    <p>The Mafia game, also known as Werewolf, is a popular social deduction game that engenders a compelling mix of strategic deception, persuasive argumentation, and probabilistic reasoning. Despite its simple rules, the game exhibits rich strategic depth and complexity due to the hidden information and the need for players to infer other players' identities based on their actions and statements. This paper presents a formal model and logical framework to analyze and understand the underlying strategies in the Mafia game.</p>
    <p>In the first part, we introduce the game and its mechanics, explaining the roles, rules, and the cycle of day and night phases. We highlight the objectives of the two factions: the innocent villagers and the deceptive mafiosi, outlining the fundamental dichotomy between hidden and public information in the game.</p>
    <p>We then proceed to construct a Kripke model representing the various game states, defining the epistemic states and transitions that correspond to players gaining information throughout the game. For single mafiosi and dual mafiosi scenarios, we propose distinct model structures, capturing the different strategic nuances in each setting.</p>
    <p>Next, we enumerate four essential types of knowledge that players can learn during the game, from witnessing specific actions to interpreting announcements made by other players. We illustrate how these knowledge types can shape the strategies players adopt.</p>
    <p>Following this, we introduce a set of reasoning rules that players may use to deduce the hidden roles based on observable actions and shared information. These rules, grounded in modal logic, provide a formal methodology for players to evaluate suspicions and make decisions.</p>
    <p>This study offers valuable insights into the strategic dynamics of the Mafia game, shedding light on how logical reasoning and information asymmetry drive the intrigue and suspense that define this classic social deduction game. The proposed logical framework and reasoning rules could inform the development of AI agents capable of playing such games, further enhancing our understanding of these complex, interactive multi-agent systems.</p>
    <!-- <figure>
      <img src="imgs/" alt="An image title." style="max-width: 100%; height: auto; width: 800px">
      <figcaption>Fig.1 - First image.</figcaption>
    </figure> -->

  <a id="introduction"></a>
  <h2>Introduction</h2>
    <p>Welcome to the thrilling and mysterious world of the Mafia game! This classic party game, also known as Werewolf, is a social deduction game that engages players in a battle of wits, persuasion, and strategy. It's a game of secrecy and subterfuge, where the aim is to unveil hidden identities while keeping your own intentions hidden. Here's a brief introduction before we delve into the logic behind it.</p>

    <p>The game is played with a group of people, traditionally ranging from six to twenty players. This group is secretly divided into two factions: the innocent villagers and the cunning mafiosi. The villagers do not know who the mafiosi are, but the mafiosi know each other. The objective of the game is different for each group. The villagers aim to identify and eliminate all the mafiosi, while the mafiosi aim to reach numerical parity with the villagers, therefore gaining control of the village.</p>

    <p>The game progresses in alternating cycles of 'night' and 'day'. During the night, the mafiosi conspire to 'eliminate' one villager, while the villagers are 'asleep' and unaware of these happenings. Come day, the villagers discover who has been 'eliminated' during the night, and then engage in discussions, accusations, and debates to figure out who amongst them could be a mafioso. This often culminates in a vote, where the suspected mafioso is 'lynched' if the majority agrees.</p>

    <p>Throughout the game, players must use their observation skills, strategic thinking, and persuasive abilities to convince others of their innocence or to cast suspicion on others. The game involves much bluffing, suspicion, interrogation, and strategic voting.</p>

    <p>In the following sections, we will unravel the fascinating logic behind the Mafia game. We will illustrate how the seemingly chaotic discussions and accusations can be analyzed using the principles of deductive reasoning, probability, and game theory. You will discover that beneath the veil of secrecy, lies, and accusations, the game of Mafia is a compelling test of logical thinking and strategy. So, let's delve deeper into the intriguing world of the Mafia game!</p>
  
    <h3>Roles</h2>
    <ul>
      <li>Villagers: Villagers are the majority faction in the game. They have no special abilities and aim to identify and eliminate the Mafiosi.</li>
      <li>Mafiosi: Mafiosi are the minority faction in the game. They aim to outnumber and eliminate the Villagers without revealing their true identities.</li>
      <li>Informant: The Informant is a special role on the Villagers' side. They have the ability to investigate the role of a player during the night phase and gather information about their allegiance.</li>
      <li>Doctor: The Doctor is another special role on the Villagers' side. They have the ability to protect a player from being eliminated during the night phase.</li>
    </ul>
    
    <h3>Public Announcements</h3>
    <p>Public announcements occur at the end of each phase and provide common knowledge to all players. These announcements may include the outcomes of investigations, eliminations, or protective actions taken by the Informant or Doctor.</p>
    <p>Based on the public announcements, players update their knowledge mappings, and the relations Kp are adjusted accordingly.</p>
    
    <h2>Gameplay and Strategies</h2>
    <p>The gameplay of Mafia involves alternating day and night phases, with players performing different actions based on their roles. During the day, players discuss and deliberate to identify potential Mafiosi and decide on a player to eliminate by voting. During the night, players with special roles take actions privately.</p>
    <p>Players can employ different strategies and logical reasoning to deduce the roles of other players and make informed decisions. The Informant can investigate players to gain information about their roles, while the Doctor can protect players who are likely targets of the Mafiosi.</p>
    <p>Throughout the game, the Kripke model is updated based on the actions and public announcements, allowing players to refine their knowledge and make more accurate deductions.</p>
    
    <h3>Game Mechanics</h3>
    <ul>
      <li>Day Phase:
        <ul>
          <li>Players engage in open discussion to gather information and form suspicions.</li>
          <li>A vote is conducted to eliminate a player who is suspected of being a Mafioso.</li>
          <li>If a majority vote is reached, the player with the most votes is eliminated. If there is a tie, no elimination occurs.</li>
          <li>The Kripke model is updated based on the outcome of the vote and public knowledge.</li>
        </ul>
      </li>
      <li>Night Phase:
        <ul>
          <li>Special roles, such as the Informant and Doctor, take their respective actions privately.</li>
          <li>The Informant can choose a player to investigate, and the result is announced publicly.</li>
          <li>The Doctor can choose a player to protect, reducing the chances of that player being eliminated by the Mafiosi.</li>
          <li>The Kripke model is updated based on the actions and public announcements during the night phase.</li>
        </ul>
      </li>
      <li>Elimination and Win Conditions:
        <ul>
          <li>The game continues with alternating day and night phases until one faction achieves their win condition.</li>
          <li>Villagers win if all Mafiosi are eliminated.</li>
          <li>Mafiosi win if their numbers equal or exceed the number of Villagers.</li>
          <li>The Kripke model is constantly updated, and players make deductions based on their knowledge to identify and eliminate the opposing faction.</li>
        </ul>
      </li>
    </ul>

  <a id="code"></a>
  <h2>Code</h2>
  <p>This project encompasses a simulation of the "Mafia" game, applying Kripke semantics to model and reason about the knowledge and beliefs of the players.</p>

  <h2>1. Kripke Model</h2>
  <p>The KripkeModel class is built upon the networkx.DiGraph class, representing the Kripke model as a directed graph. Each player in the game is a node in the graph, and edges represent the relationships between players in terms of their beliefs.</p>

  <h2>2. Mafia Game</h2>
  <p>The MafiaGame class governs the main gameplay logic. It initializes players of different roles (mafioso, villager, doctor, and informant) and manages the state of the game including the living and dead players, as well as the voting and killing mechanics. It also checks for win conditions.</p>

  <h2>3. Mafia Players</h2>
  <p>The mafia_players.py script defines the Player class and its subclasses corresponding to different roles in the game. Each player maintains their own set of beliefs about the roles of other players. Mafioso and Informant have specific knowledge about the roles of other players, and this knowledge is incorporated into their belief sets.</p>

  <h2>4. Main Script</h2>
  <p>The main script combines all the components above and provides a graphical interface for the game. It initializes a game, performs rounds of night and day phases, and allows players to vote and kill each other based on their beliefs. It also updates and displays the Kripke model after each round.</p>

  <p>All these scripts interplay with each other to form the complete gameplay. Each player's belief system is updated and represented in the Kripke model, which in turn influences the decisions made during the game (who to vote or kill). This iterative process continues until a win condition is met, demonstrating an application of Kripke semantics in modeling complex social scenarios.</p>


  <a id="kripke_model"></a>
  <h2>Kripke Model</h2>

  <h2>Kripke Model Representation</h2>
  <p>To formalize the game using Kripke models, we define the following elements:</p>
  
  <h3>States</h3>
  <p>A state represents a possible configuration of the game, including the roles assigned to players and their current knowledge.</p>
  <p>Let S be the set of states, and each state s ∈ S is represented as a tuple of player-role assignments and knowledge mappings. For example, s = (p1 → R1, p2 → R2, ..., pn → Rn, K1, K2, ..., Kn), where p1, p2, ..., pn are the players, R1, R2, ..., Rn are their respective roles, and K1, K2, ..., Kn represent the knowledge mappings.</p>
  
  <h3>Propositions</h3>
  <p>Propositions represent the possible statements or facts about the game. We define the following propositions:</p>
  <ul>
    <li>Role propositions: For each player p, we have propositions Rp for the respective role assigned to player p.</li>
    <li>Knowledge propositions: For each player p and each player q, we have propositions Kpq for player p's knowledge about the role of player q.</li>
    <li>Alive propositions: For each player p, we have propositions Ap representing whether player p is alive or eliminated.</li>
  </ul>
  
  <h3>Relations</h3>
  <p>We define the following relations for each player:</p>
  <ul>
    <li>Role relations: Rp ⊆ S × S such that Rp = {(s, t) ∈ S × S | s(p) = t(p)}, meaning that the assigned role of player p remains the same between states s and t.</li>
    <li>Knowledge relations: Kp ⊆ S × S such that Kp = {(s, t) ∈ S × S | s(Kp) ⊆ t(Kp)}, meaning that player p's knowledge is preserved or expanded between states s and t.</li>
    <li>Alive relations: Ap ⊆ S × S such that Ap = {(s, t) ∈ S × S | s(Ap) = t(Ap)}, meaning that player p's status (alive or eliminated) remains the same between states s and t.</li>
  </ul>

  <h3>Transitions</h3>
  <p>Transitions between states occur based on the actions taken by players during the game. The transitions are defined as the union of role, knowledge, and alive relations for all players. Formally, R = R1 ∪ R2 ∪ ... ∪ Rn, K = K1 ∪ K2 ∪ ... ∪ Kn, and A = A1 ∪ A2 ∪ ... ∪ An.</p>

  
  <a id="results_discussion"></a>
  <h2>Results and Discussion</h3>
  <p>The Mafia Game Simulation successfully replicates the dynamics of a typical game of Mafia, with alternating day and night phases and various roles participating in the decision-making process. The simulation allows us to observe and analyze the game's progression and outcomes in a controlled and repeatable manner.</p>
  <p>The simulation allows us to evaluate how effectively each role performs in the context of the game. For example, we can measure how often the Mafia is successful in deceiving the villagers or how often the Doctor or Informant roles are able to protect or inform their fellow villagers, respectively.</p>
  <p>The use of Kripke structures in representing player knowledge offers valuable insight into how the game dynamics change as players gain, lose, or alter their beliefs about other players. The graphical representation of these structures allows for easy visualization of the game's epistemic state at any given point.</p>
  <p>In essence, the simulation effectively demonstrates how the Mafia game operates, provides tools for strategy analysis and role performance, and showcases a complex example of knowledge representation and belief revision in action.</p>


  <h3>Discussion</h3>
    <p>The simulation of the Mafia game developed in this project offers a unique perspective on how epistemic logic and belief revision can be applied to model real-world systems. It highlights how individuals use their knowledge and the knowledge of others to make decisions, and how these decisions can affect the overall outcome of a system or situation.</p>

    <p>Through this simulation, we were able to investigate different strategies used by the players in the game, specifically the Mafiosi and the Villagers. Different strategies lead to different game outcomes, which raises the question of what the optimal strategy might be for each role.</p>

    <p>It was also interesting to observe how the beliefs of the players changed throughout the game. By integrating a graphical user interface, we could visualize these changes in beliefs and how they impacted the decisions of the players. This aspect of the simulation demonstrates the dynamic nature of knowledge and belief in complex systems.</p>

    <p>One limitation of the current implementation, however, is that it does not consider emotions or irrational behavior, which could be potential areas for future work. Overall, this project has provided valuable insights into the interplay between knowledge, belief, decision-making, and group dynamics.</p>
     
  <a id="conclusion"></a>
  <h2>Conclusion</h2>

    <p>The Mafia Game Simulation is a compelling implementation of the popular party game Mafia, realized through the Python programming language and visualized through an interactive GUI. By leveraging the mechanics of the game, this simulation offers a framework for analyzing player behavior, decision-making strategies, and the effects of information asymmetry on group dynamics.</p>

    <p>Through the use of Kripke structures and belief revision, the simulation provides a sophisticated model of how player knowledge changes over the course of the game. This aspect of the simulation illuminates the underpinnings of epistemic logic in a tangible and relatable context, showcasing its utility in representing and reasoning about knowledge and beliefs.</p>

    <p>Furthermore, the modularity of the implementation allows for the exploration of various strategies and game settings, making it a valuable tool for both educational purposes and strategy optimization. It successfully illustrates how different game roles can impact the overall game outcomes.</p>

    <p>In conclusion, this Mafia Game Simulation serves as a useful tool for studying group dynamics, decision-making strategies, and knowledge representation, all within the exciting and engaging context of the classic Mafia game.</p>


  <a id="contributions"></a>
  <h2>Contributions</h2>

  <table style="width:100%; border: 1px solid black; text-align:center">
      <tr>
          <th>Name</th>
          <th>Student ID</th>
          <th>Website Contribution</th>
          <th>Code Contribution</th>
          <th>Background Research Contribution</th>
      </tr>
      <tr>
          <td>Chrysoula-Maria Nampouri</td>
          <td>s4721810</td>
          <td>33.33%</td>
          <td>33.33%</td>
          <td>33.33%</td>
      </tr>
      <tr>
          <td>Daan Windt</td>
          <td>s3486427</td>
          <td>33.33%</td>
          <td>33.33%</td>
          <td>33.33%</td>
      </tr>
      <tr>
          <td>Gonçalo Hora de Carvalho</td>
          <td>s3450295</td>
          <td>33.33%</td>
          <td>33.33%</td>
          <td>33.33%</td>
      </tr>
  </table>

  <h3 id="references" class="unnumbered">References</h3>
  <div id="refs" class="references">

  <!-- <div id="ref-partition">
  <p>Reid, John. 2007. “Equivalence Partition (Python Recipe).” <a href="https://code.activestate.com/recipes/499354-equivalence-partition/">https://code.activestate.com/recipes/499354-equivalence-partition/</a>.</p>
  </div> -->
  </div>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["jsMath2jax.js"]
    });
  </script>

  <script
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  </script>

  <script>
      window.onscroll = function() {myFunction()};

      var header = document.getElementById("myHeader");
      var sticky = header.offsetTop;

      function myFunction() {
        if (window.pageYOffset > sticky) {
          header.classList.add("sticky");
        } else {
          header.classList.remove("sticky");
        }
      }

  function offsetAnchor() {
      if(location.hash.length !== 0) {
          window.scrollTo(window.scrollX, window.scrollY);
      }
  }
  window.addEventListener("hashchange", offsetAnchor);
  window.setTimeout(offsetAnchor, 1);


  </script>

<!-- <h1>Simple Mafia Game Simulation</h1>
<button id="start-btn">Start Game</button>
<h2>Game Log:</h2>
<div id="game-log"></div>

<script>
  const players = ['Player 1', 'Player 2', 'Player 3', 'Player 4', 'Player 5'];
  let mafiosi = '';

  function log(message) {
    const gameLog = document.getElementById('game-log');
    gameLog.innerHTML += message + '<br />';
    gameLog.scrollTop = gameLog.scrollHeight;
  }

  function startGame() {
    mafiosi = players[Math.floor(Math.random() * players.length)];
    log(`Game Start. Players: ${players.join(', ')}`);
    log(`Mafioso chosen (hidden): ${mafiosi}`);
  }

  function nightPhase() {
    const killed = players[Math.floor(Math.random() * players.length)];
    log(`Night Phase: ${killed} was killed.`);
    const index = players.indexOf(killed);
    if (index > -1) {
      players.splice(index, 1);
    }
  }

  function dayPhase() {
    log(`Day Phase: Living Players: ${players.join(', ')}`);
    if (players.includes(mafiosi)) {
      log('The Mafia is still among us...');
      nightPhase();
    } else {
      log('The villagers have won, the Mafia was eliminated!');
    }
  }

  document.getElementById('start-btn').addEventListener('click', function() {
    startGame();
    nightPhase();
    dayPhase();
  }); -->
</script>

</body>
</html>